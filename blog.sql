-- Adminer 4.3.1 MySQL dump

SET NAMES utf8;
SET time_zone = '+00:00';
SET foreign_key_checks = 0;
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

CREATE DATABASE `blog` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `blog`;

DROP TABLE IF EXISTS `blog_article`;
CREATE TABLE `blog_article` (
  `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '博文主键',
  `title` varchar(200) NOT NULL COMMENT '博文标题',
  `order` int(4) NOT NULL DEFAULT '0' COMMENT '排序',
  `content` text NOT NULL COMMENT '内容',
  `cat_id` int(4) NOT NULL COMMENT '所属分类',
  `recommend` int(4) NOT NULL DEFAULT '1' COMMENT '是否推荐',
  `title_url` varchar(200) NOT NULL COMMENT '博文地址',
  `create_time` int(10) NOT NULL COMMENT '创建时间',
  `update_time` int(10) NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `cat_id` (`cat_id`),
  CONSTRAINT `blog_article_ibfk_1` FOREIGN KEY (`cat_id`) REFERENCES `blog_category` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `blog_article` (`id`, `title`, `order`, `content`, `cat_id`, `recommend`, `title_url`, `create_time`, `update_time`) VALUES
(35,	'php工厂模式的使用实例总结1',	1,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=35',	1504320195,	1504320195),
(36,	'php工厂模式的使用实例总结2',	2,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=36',	1504320195,	1504320195),
(37,	'php工厂模式的使用实例总结3',	3,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=37',	1504320195,	1504320195),
(38,	'php工厂模式的使用实例总结4',	4,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=38',	1504320195,	1504320195),
(39,	'php工厂模式的使用实例总结5',	5,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=39',	1504320195,	1504320195),
(40,	'php工厂模式的使用实例总结6',	6,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=40',	1504320195,	1504320195),
(41,	'php工厂模式的使用实例总结7',	7,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=41',	1504320195,	1504320195),
(42,	'php工厂模式的使用实例总结8',	8,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=42',	1504320195,	1504320195),
(43,	'php工厂模式的使用实例总结9',	9,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=43',	1504320195,	1504320195),
(44,	'php工厂模式的使用实例总结10',	10,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=44',	1504320195,	1504320195),
(45,	'php工厂模式的使用实例总结11',	11,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=45',	1504320195,	1504320195),
(46,	'php工厂模式的使用实例总结12',	12,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=46',	1504320195,	1504320195),
(47,	'php工厂模式的使用实例总结13',	13,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=47',	1504320195,	1504320195),
(48,	'php工厂模式的使用实例总结14',	14,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=48',	1504320195,	1504320195),
(49,	'php工厂模式的使用实例总结15',	15,	'            &lt;p&gt;这篇文章主要介绍了PHP设计模式之工厂模式,简单介绍了工厂模式的概念、原理并结合实例形式总结分析了工厂模式的具体定义及使用方法,需要的朋友可以参考下&lt;/p&gt;&lt;p&gt;本文实例讲述了PHP设计模式之工厂模式。分享给大家供大家参考，具体如下：&lt;/p&gt;&lt;p&gt;使用工厂模式的目的或目标？&lt;/p&gt;&lt;p&gt;工厂模式的最大优点在于创建对象上面，就是把创建对象的过程封装起来，这样随时可以产生一个新的对象。&lt;/p&gt;&lt;p&gt;减少代码进行复制粘帖，耦合关系重，牵一发动其他部分代码。&lt;/p&gt;&lt;p&gt;通俗的说，以前创建一个对象要使用new，现在把这个过程封装起来了。&lt;/p&gt;&lt;p&gt;假设不使用工厂模式：那么很多地方调用类a，代码就会这样子创建一个实例：new a(),假设某天需要把a类的名称修改，意味着很多调用的代码都要修改。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。&lt;/p&gt;&lt;p&gt;工厂模式的优点就在创建对象上。建立一个工厂（一个函数或一个类方法）来制造新的对象,它的任务就是把对象的创建过程都封装起来，&lt;/p&gt;&lt;p&gt;创建对象不是使用new的形式了。而是定义一个方法，用于创建对象实例。&lt;/p&gt;&lt;p&gt;每个类可能会需要连接数据库。那么就将连接数据库封装在一个类中。以后在其他类中通过类名:&lt;/p&gt;&lt;p&gt;为什么引入抽象的概念？&lt;/p&gt;&lt;p&gt;想一想，在现实生活中，当我们无法确定某个具体的东西的时候，往往把一类东西归于抽象类别。&lt;/p&gt;&lt;p&gt;工厂方法：&lt;/p&gt;&lt;p&gt;比如你的工厂叫做“香烟工厂”，那么可以有“七匹狼工厂”“中华工厂”等，但是，这个工厂只生厂一种商品：香烟；&lt;/p&gt;&lt;p&gt;抽象工厂：无法描述它到底生产什么产品，它生产很多类型的产品(所以抽象工厂就会生成子工厂)。&lt;/p&gt;&lt;p&gt;你的工厂是综合型的，是生产“一系列”产品，而不是“一个”，比如：生产“香烟”，还有“啤酒”等。然后它也可以有派生出来的具体的工厂，但这些工厂都是生产这一系列产品，只是可能因为地域不一样，为了适应当地人口味，味道也不太一样。&lt;/p&gt;&lt;p&gt;工厂模式：理解成只生成一种产品的工厂。比如生产香烟的。&lt;/p&gt;&lt;p&gt;工厂方法：工厂的一种产品生产线 。比如键盘的生成过程。&lt;/p&gt;&lt;p&gt;别人会反驳：吃饱了没事干，一定要修改类名称呢？这个说不定。一般都不会去修改类名称。&lt;/p&gt;&lt;p&gt;其实工厂模式有很多变体，抓住精髓才是关键：只要是可以根据不同的参数生成不同的类实例，那么就符合工厂模式的设计思想。&lt;/p&gt;&lt;p&gt;这样子让我联想到框架中经常会有负责生成具体类实例的方法供调用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	1,	1,	'?cat=1&id=49',	1504320195,	1504320195),
(50,	'Mysql中关于事务处理的详细介绍1',	1,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=50',	1504338998,	1504338998),
(51,	'Mysql中关于事务处理的详细介绍2',	2,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=51',	1504338998,	1504338998),
(52,	'Mysql中关于事务处理的详细介绍3',	3,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=52',	1504338998,	1504338998),
(53,	'Mysql中关于事务处理的详细介绍4',	4,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=53',	1504338998,	1504338998),
(54,	'Mysql中关于事务处理的详细介绍5',	5,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=54',	1504338998,	1504338998),
(55,	'Mysql中关于事务处理的详细介绍6',	6,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=55',	1504338998,	1504338998),
(56,	'Mysql中关于事务处理的详细介绍7',	7,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=56',	1504338998,	1504338998),
(57,	'Mysql中关于事务处理的详细介绍8',	8,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=57',	1504338998,	1504338998),
(58,	'Mysql中关于事务处理的详细介绍9',	9,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=58',	1504338998,	1504338998),
(59,	'Mysql中关于事务处理的详细介绍10',	10,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=59',	1504338998,	1504338998),
(60,	'Mysql中关于事务处理的详细介绍11',	11,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=60',	1504338998,	1504338998),
(61,	'Mysql中关于事务处理的详细介绍12',	12,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=61',	1504338998,	1504338998),
(62,	'Mysql中关于事务处理的详细介绍13',	13,	'            &lt;p&gt;什么是事务处理呢？？事务处理是用来维护数据库的完整性的，它保证成批的MySQL操作要么完全执行，要么完成不执行。&lt;/p&gt;&lt;p&gt;一、Mysql事务概念&lt;/p&gt;&lt;p&gt;　MySQL 事务主要用于处理操作量大，复杂度高的数据。由一步或几步数据库操作序列组成逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务用来管理 insert,update,delete 语句。&lt;/p&gt;&lt;p&gt;二、事务特性：Atomicity(原子性)、Consistency（稳定性,一致性）、隔离性（Isolation）和Durability(持续性,可靠性)。这四个特性也简称ACID性。&lt;/p&gt;&lt;p&gt;　　1.原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特征一样。事务是应用中不可再分的最小逻辑执行体,一组事务，要么成功；要么撤回。&lt;/p&gt;&lt;p&gt;　　2.稳定性,一致性：事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。有非法数据（外键约束之类），事务撤回。&lt;/p&gt;&lt;p&gt;　　3.隔离性：各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间不能看到对方的中间状态，并发执行的事务之间不能相互影响。事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。&lt;/p&gt;&lt;p&gt;　　4.持续性,可靠性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库。软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。&lt;/p&gt;&lt;p&gt;　　注意事项：存储引擎MyISAM不支持事物，存储引擎InnoDB支持事物。事务只针对对数据数据产生影响的语句有效。show engines 查看mysql锁支持的数据引擎。&lt;/p&gt;&lt;p&gt;三、读取数据概念&lt;/p&gt;&lt;p&gt;　　1.脏读（Dirty Reads）：所谓脏读就是对脏数据的读取，而脏数据所指的就是未提交的数据。一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。&lt;/p&gt;&lt;p&gt;　　2.不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。&lt;/p&gt;&lt;p&gt;　　3.幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',	2,	1,	'?cat=2&id=62',	1504338998,	1504338998),
(63,	'JavaScript中有关数组常见操作技巧1',	3,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=63',	1504446004,	1504447583),
(64,	'JavaScript中有关数组常见操作技巧2',	2,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=64',	1504446004,	1504447692),
(65,	'JavaScript中有关数组常见操作技巧3',	3,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=65',	1504446004,	1504447698),
(66,	'JavaScript中有关数组常见操作技巧4',	4,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=66',	1504446004,	1504447707),
(67,	'JavaScript中有关数组常见操作技巧5',	5,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=67',	1504446004,	1504447714),
(68,	'JavaScript中有关数组常见操作技巧6',	6,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=68',	1504446004,	1504447714),
(69,	'JavaScript中有关数组常见操作技巧7',	7,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=69',	1504446004,	1504447714),
(70,	'JavaScript中有关数组常见操作技巧8',	8,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=70',	1504446004,	1504447714),
(71,	'JavaScript中有关数组常见操作技巧9',	9,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=71',	1504446004,	1504447714),
(72,	'JavaScript中有关数组常见操作技巧10',	10,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=72',	1504446004,	1504447714),
(73,	'JavaScript中有关数组常见操作技巧11',	11,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=73',	1504446004,	1504447714),
(74,	'JavaScript中有关数组常见操作技巧12',	12,	'                &lt;p&gt;String.prototype.split()&amp;nbsp;方法用于把一个字符串分割成字符串数组。&amp;nbsp;split()&amp;nbsp;方法不改变原始字符串。&lt;/p&gt;&lt;p&gt;li.innerHTML.split(&quot;空气质量：&quot;)-----这个拆成的数组为[&quot;北京&quot;，&quot;90&quot;]的数组，再取数组&lt;/p&gt;&lt;p&gt;的第一项，即城市值。&lt;/p&gt;&lt;p&gt;Text.splitText()方法会将一个文本节点分成两个文本节点，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点&lt;/p&gt;&lt;p&gt;querySelector()方法接收一个CSS选择符，返回与改模式匹配的第一个元素，如果没有找到，则返回null&lt;/p&gt;&lt;p&gt;querySelectorAll()方法接受一个CSS选择符，返回一个NodeList对象，如果没有找到，则为空&lt;/p&gt;&lt;p&gt;读取和设置&lt;/p&gt;&lt;p&gt;存取数组元素&lt;/p&gt;&lt;p&gt;一维数组&lt;/p&gt;&lt;p&gt;arr[下标索引]&lt;/p&gt;&lt;p&gt;多维数组&lt;/p&gt;&lt;p&gt;arr[外层数组下标][内层元素下标]&lt;/p&gt;&lt;p&gt;length属性&lt;/p&gt;&lt;p&gt;添加新项&lt;/p&gt;&lt;p&gt;arr[array.length]&amp;nbsp;=&amp;nbsp;[]&lt;/p&gt;&lt;p&gt;清空数组或清除&lt;/p&gt;&lt;p&gt;arr.length&amp;nbsp;=&amp;nbsp;0&amp;nbsp;||&amp;nbsp;(少于项数的数值)&lt;/p&gt;&lt;p&gt;判断数组非空&lt;/p&gt;&lt;p&gt;if(arr.length)&amp;nbsp;{}&lt;/p&gt;&lt;p&gt;数组遍历&lt;/p&gt;&lt;p&gt;遍历数组不使用for&amp;nbsp;in，因为数组对象可能存在数字以外的属性，这种情况下for&amp;nbsp;in不会得到正确结果&lt;/p&gt;&lt;p&gt;推荐使用forEach()方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用传统的for循环&lt;/p&gt;&lt;pre style=&quot;max-width: 100%;&quot;&gt;&lt;code class=&quot;javascript hljs&quot; codemark=&quot;1&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i++){}\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;...in\r\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arrayObj){\r\n &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = arrayObj[index];\r\n}\r\nforEach()\r\narr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;currentValue, index, array&lt;/span&gt;) &lt;/span&gt;{\r\n &lt;span class=&quot;hljs-comment&quot;&gt;//your iterator&lt;/span&gt;\r\n}[, thisArg]);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;            ',	3,	1,	'?cat=3&id=74',	1504446004,	1504447714);

DROP TABLE IF EXISTS `blog_category`;
CREATE TABLE `blog_category` (
  `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '分类主键',
  `cat_name` varchar(200) NOT NULL COMMENT '分类名称',
  `order` int(4) NOT NULL DEFAULT '0' COMMENT '分类排序',
  `cat_url` varchar(200) NOT NULL,
  `create_time` int(10) NOT NULL COMMENT '创建时间',
  `update_time` int(10) NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `blog_category` (`id`, `cat_name`, `order`, `cat_url`, `create_time`, `update_time`) VALUES
(1,	'php',	1,	'?cat=1',	1504755105,	1505737004),
(2,	'mysql',	2,	'?cat=2',	1504755110,	1504755110),
(3,	'javascript',	3,	'?cat=3',	1504755113,	1504846622),
(4,	'html',	8,	'?cat=4',	1505737027,	1505737027);

DROP TABLE IF EXISTS `blog_user`;
CREATE TABLE `blog_user` (
  `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '用户主键',
  `username` varchar(50) NOT NULL COMMENT '用户名',
  `password` varchar(50) NOT NULL COMMENT '用户密码',
  `email` varchar(100) DEFAULT NULL COMMENT '用户邮箱',
  `update_time` int(10) NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `blog_user` (`id`, `username`, `password`, `email`, `update_time`) VALUES
(1,	'admin',	'e10adc3949ba59abbe56e057f20f883e',	'admin@php.cn',	1504755097);

-- 2017-09-19 11:08:51
